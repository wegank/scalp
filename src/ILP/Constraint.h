
#pragma once

#include <string.h>

#include <ILP/Term.h>
#include <ILP/Variable.h>



namespace ILP
{
  /** An enum-representation of relational operators
   */
  enum class relation
  { LESS_EQ_THAN
  , MORE_EQ_THAN
  , EQUAL
  };

  extern double INF();

  /** \brief A representation of ILP Constaints
   *
   * Objects are generated by using the relational operators
   */
  class Constraint
  {
    public:
      // construct Constraints
      Constraint(double l, relation rel, ILP::Term& r);
      Constraint(ILP::Term& l, relation rel, double r);
      Constraint(double lb, relation lrel, ILP::Term& t, relation rrel,double ub);

      // combine Constraints
      Constraint(ILP::Constraint& lhs, relation rel, double ub);
      Constraint(double lb, relation rel, ILP::Constraint& rhs);

      // named constraint constructor
      Constraint(std::string n, ILP::Constraint& c);
      Constraint(std::string n, ILP::Constraint&& c);
      Constraint(std::pair<std::string,ILP::Constraint>& p);

      // empty Constraint
      Constraint(){};

      void setName(std::string n);

      static std::string showRelation(relation r);

      ILP::VariableSet extractVariables() const;

      std::string show() const;

      enum class type
      { C2L // d R x
      , C2R // x R d
      , CEQ // x == d or d == x
      , C3  // d R x R d
      };

      std::string name="";

      type ctype;

      double lbound=-ILP::INF();
      relation lrel = ILP::relation::LESS_EQ_THAN;
      Term term;
      relation rrel = ILP::relation::LESS_EQ_THAN;
      double ubound=ILP::INF();

    private:
      bool valid(); // check, if the constraint is valid
  };

}

std::ostream& operator<<(std::ostream& os, const ILP::Constraint &c);
