
#pragma once

#include <string.h>

#include <ILP/Term.h>
#include <ILP/Variable.h>


namespace ILP
{
  /** An enum-representation of relational operators
   */
  enum class relation
  { LESS_EQ_THAN
  , LESS_THAN
  , MORE_EQ_THAN
  , MORE_THAN
  , EQUAL
  };

  class Constraint2
  {
    public:
    Term lhs;
    relation usedRelation;
    Term rhs;
    Constraint2(ILP::Term l, relation rel, ILP::Term r);
    Constraint2(){}
  };
  class Constraint3
  {
    public:
    Term lbound;
    relation lrel;
    Term term;
    relation rrel;
    Term ubound;
    Constraint3(Term lb, relation lrel, ILP::Term t, relation rrel,Term ub);
    Constraint3();
  };

  /** \brief A representation of ILP Constaints
   *
   * Objects are generated by using the relational operators
   */
  class Constraint
  {
    public:
      // construct Constraints
      Constraint(ILP::Term l, relation rel, ILP::Term r);
      Constraint(ILP::Term lb, relation lrel, ILP::Term t, relation rrel,ILP::Term ub);

      // Convert ConstraintX to Constraint
      Constraint(ILP::Constraint3 c);
      Constraint(ILP::Constraint2 c);

      // combine Constraints
      Constraint(ILP::Constraint lhs, relation rel, ILP::Term ub);
      Constraint(ILP::Term lb, relation rel, ILP::Constraint rhs);

      enum class type
      {
        Constraint_2
      , Constraint_3
      };

      type usedType;
      // TODO: replace with an union
      Constraint2 c2;
      Constraint3 c3;

      static std::string showRelation(relation r);

      ILP::VariableSet extractVariables() const;

      std::string show() const;

    private:
  };

}

std::ostream& operator<<(std::ostream& os, const ILP::Constraint &c);
std::ostream& operator<<(std::ostream& os, const ILP::Constraint2 &c);
std::ostream& operator<<(std::ostream& os, const ILP::Constraint3 &c);
