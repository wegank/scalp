
#pragma once

#include <string.h>
#include <memory>

#include <ScaLP/Term.h>
#include <ScaLP/Variable.h>
#include <ScaLP/Result.h>



namespace ScaLP
{
  /** An enum-representation of relational operators
   */
  enum class relation : char
  { LESS_EQ_THAN
  , MORE_EQ_THAN
  , EQUAL
  };

  extern double INF();

  /** \brief A representation of ScaLP Constaints
   *
   * Objects are generated by using the relational operators
   */
  class Constraint
  {
    public:
      // construct Constraints
      Constraint(double l, relation rel, const ScaLP::Term& r);
      Constraint(const ScaLP::Term& l, relation rel, double r);
      Constraint(double lb, relation lrel, const ScaLP::Term& t, relation rrel,double ub);
      Constraint(double l, relation rel, ScaLP::Term&& r);
      Constraint(ScaLP::Term&& l, relation rel, double r);
      Constraint(double lb, relation lrel, ScaLP::Term&& t, relation rrel,double ub);

      // combine Constraints
      Constraint(const ScaLP::Constraint& lhs, relation rel, double ub);
      Constraint(double lb, relation rel, const ScaLP::Constraint& rhs);

      // named constraint constructor
      Constraint(const std::string& n, const ScaLP::Constraint& c);
      Constraint(const std::string& n, ScaLP::Constraint&& c);
      Constraint(const std::pair<std::string,ScaLP::Constraint>& p);

      // indicator constraint combination
      Constraint(ScaLP::Constraint i, ScaLP::Constraint c);

      // empty Constraint
      Constraint(){};

      // copy-Constructor
      Constraint(const Constraint&) = default;
      Constraint(Constraint&&) = default;
      Constraint& operator=(const Constraint&) = default;
      Constraint& operator=(Constraint&&) = default;

      ~Constraint();

      void setName(const std::string& n);

      static std::string showRelation(relation r);

      ScaLP::VariableSet extractVariables() const;

      std::string show() const;

      bool isFeasible(const ScaLP::Result& sol);

      enum class type: char
      { C2L // d R x
      , C2R // x R d
      , CEQ // x == d or d == x
      , C3  // d R x R d
      };

      double lbound=-ScaLP::INF();
      double ubound=ScaLP::INF();
      relation lrel = ScaLP::relation::LESS_EQ_THAN;
      relation rrel = ScaLP::relation::LESS_EQ_THAN;
      type ctype;
      Term term;
      std::string name="";
      std::shared_ptr<Constraint> indicator=nullptr;

    private:
  };
  std::ostream& operator<<(std::ostream& os, const ScaLP::Constraint &c);

}

